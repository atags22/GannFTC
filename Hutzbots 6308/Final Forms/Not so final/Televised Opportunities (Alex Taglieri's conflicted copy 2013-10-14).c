#pragma config(Hubs,	S4, HTMotor,	HTMotor,	none,			none)
#pragma config(Sensor, S2,		 compass,				 sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,		 colur,					 sensorI2CHiTechnicColor)
#pragma config(Motor,	 mtr_S4_C1_1,			FR,						 tmotorTetrix, openLoop, reversed)
#pragma config(Motor,	 mtr_S4_C1_2,			BR,						 tmotorTetrix, openLoop, reversed)
#pragma config(Motor,	 mtr_S4_C2_1,			BL,						 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S4_C2_2,			FL,						 tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/*////////////////////////////////////////////////////////////////////////////////////////////////////
//																		 Hutzbots Teleop Code
//
//																							A
//																						 / \
//																						/		\
//																			<----+-----+---->
//																			 \	/				\	 /
//																				\/	Teleop \/
//																				/\				 /\
//																			 /	\				/	 \
//																			<----+-----+---->
//																						\		/
//																						 \ /
//																							V
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////*/
//							Controlling our robot with a joystick and stuff.
////////////////////////////////////////////////////////////////////////////////////////////////////
// Alex Tagieri (math/music), Joshua Hailman (form, appearance, comments, design)
////////////////////////////////////////////////////////////////////////////////////////////////////
#include "Youtilities.c"
#include "JoystickDriver.c"

//////////////////////////////////////////////////
//							Button Counters
//////////////////////////////////////////////////
// These variables make sure our button events
// aren't toggled multiple times during execution.
//////////////////////////////////////////////////
byte bArmRaise		 = 0;
byte bSwitchMode	 = 0;
byte bToggleFilter = 0;
byte bSweepDustpan = 0;

//////////////////////////////////////////////////
//						#define'd Constants
//////////////////////////////////////////////////
// Using #define can make code easier to read
// and to edit.
/************************************************/
// How far off the compass is allowed to get
#define COMPASS_OFFSET 10
// The speed the lift should move at
#define LIFT_SPEED 10
// Scale the joystick to 100
#define JOY_SCALE 0.77
// How far off the joystick can be
#define JOY_NOISE 12
//Light sensor value reported when sensor sees line
#define threshold 17
//Button Press Timer
#define buttonTimer 50
float DrivingScale = 1;

//////////////////////////////////////////////////
//			 Text summary of the controls!
//////////////////////////////////////////////////
// Left	 joystick: drive robot omniwheel mode
// Right joystick: rotate robot / reset target compass value
// Button One: Lift arm?
// Button Two: Follow a line
// Buttons LB, RB, and Y: Play La Cuca Racha
//
//
//
//
//

//int sqr (int input) { return input * input; }
////////////////////////////////////////////////////////////////////////////////////////////////////
//																			 task main()
////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
	// for now
	userAngle = SensorValue(compass);
	int desAngle = SensorValue(compass); //Angle the robot should be facing. Used for correcting while driving straight.
	//We have different variables for rotating initiated by the driver and rotating initiated by the compass correction function.
	int joy_rotate = 0;
	int cor_rotate = 0;

	//button timer ints
	int SpeedFactor1Timer = 0;
	int SpeedFactor2Timer = 0;
	///4///////////////////////////////////////////////
	//						while (true) loop
	//////////////////////////////////////////////////
	while (true)
	{
		//////////////////////////////////////////////////
		//					Reset joystick values
		//////////////////////////////////////////////////
		getJoystickSettings(joystick);
		setProxiesToNumber(0);

		//Reset the desired angle when a button is pressed
		if (joy1Btn(11))
		{
			desAngle = SensorValue[compass];
			nVolume = 4;
			PlayTone(220, 5);
		}

		//La Cuca Racha
		if (joy1Btn(4) && joy1Btn(5) && joy1Btn(6))
		{
			//LaCucaRacha();
		}

		//Happy Birthday
		if (joy1Btn(1) && joy1Btn(5) && joy1Btn(6))
		{
			//HappyBirthday();
		}


		//speed
		if (joy1Btn(7))
			factorL = .5;
		else
			factorL = 1;

		if (joy1Btn(8))
			factorR = .5;
		else
			factorR = 1;

		factor = factorL * factorR;



		if (abs(joystick.joy1_x2) > JOY_NOISE)
		{
			joy_rotate = JOY_SCALE * (-joystick.joy1_x2);
		}
		else
		{
			joy_rotate = 0;
		}

		// Regular driving
		if (abs(joystick.joy1_x1) > JOY_NOISE || abs(joystick.joy1_y1) > JOY_NOISE)
		{
			// Get stuffs
			float theta = atan2(-joystick.joy1_y1, joystick.joy1_x1);

			float speed = sqrt(sqr(joystick.joy1_x1) + sqr(joystick.joy1_y1));
			if (speed > 100)
			{speed = 100;}


			// Apply compass to theta
			int Comp_Angle = addAngles(SensorValue[compass], -270); //The math function wants the 0 angle to be the angle to the right of the robot, but the compass reports the 0 angle as directly in front of the robot. Use comp_angle instead of sensorvalue(compass).
			float useroffset = ((Comp_Angle - userAngle) * PI/2) / 360;
			//			if (abs(useroffset) < 20) useroffset = 0;
			//theta = angleOffset(theta, useroffset);
			//theta = theta + useroffset;
//						theta = addAngles(theta, -useroffset);															 //THE FILTER LINE!!!!!
			//if (joystick.joy1_y1 > 0) theta += pi;
			// set the proxies to degree, power via vectors
			// right side is reversed // degToRad = pi / 4;


			//Reset the desired angle if robot is rotated
			if (joy_rotate)
				bool rotateTest = true;

			if (rotateTest)
				if (!joy_rotate)
			{
				desAngle = SensorValue[compass];
				rotateTest = false;
			}


			//Define cor_rotate as a proportional value to how far the robot is from where it needs to be
			//			cor_rotate = .2 * ((SensorValue[compass] - desAngle) % 360);

			driveRobot(speed, theta);


		}
		int rotate = joy_rotate;// + cor_rotate; //add two rotate values together to find the total rotate required.
		setWheelsToProxies(rotate);



		//Line following

		while(joy1Btn(2))
		{
			// sensor sees light:
			if(SensorValue(colur) == threshold)
			{
				// counter-steer left:
				driveRobot(30, 4*PI/3);
				setWheelsToProxies(0);
			}
			// sensor sees dark:
			else
			{
				// counter-steer right:
				driveRobot(30, 5 * PI/3);
				setWheelsToProxies(0);
			}

		}
	}
}
