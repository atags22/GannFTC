#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     comp,           sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     color,          sensorCOLORFULL)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     omniBL,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     omniBR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     omniFL,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     omniFR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     liftL,         tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     liftR,         tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    rotFL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    rotFR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    rotBR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    rotBL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    armBase,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    armClaw,              tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


///////////////////////////////////////////////////
//          #defines and Variables
///////////////////////////////////////////////////
int UserAngle = 0; // Used in other files!!!
//int RingAngle = 0; // Used in other files!!!
#define VARIANCE_NOISE 2 // An "Acceptable" variance count.
#define OMNI 127 // Servo value of omniwheels
#define WEBEATORONATMATH 322.58 // that magic number that we use to beat oron at math with // 2(127^2) / 100
#define ADDITIOnAL_ORON_SUCKING_VARIABLE 0.76
#define JOY_SCALE 0.78 // used to scale down from 127 -> 100
int FL_CAR = 0;
int FR_CAR = 255; // Servo value of wheels in car mode
int BL_CAR = 255;
int BR_CAR = 0;
/*************************************************/


///////////////////////////////////////////////////
//     int Variance(int record, int NewAngle)
///////////////////////////////////////////////////
// Used to compute the difference between two angles.
///////////////////////////////////////////////////
int Variance(int record, int newAngle)
{
	if (abs(record - newAngle) > 180)
		return 360 - abs(record - newAngle);

	return record - newAngle;
}
/*************************************************/


///////////////////////////////////////////////////
//      task TrackTurnDegrees(int degrees)
///////////////////////////////////////////////////
//  Used to turn the robot to face a desired angle.
// The "degrees" should be some number + some other.
///////////////////////////////////////////////////
void tTurnDegrees(int degrees)
{
	int goal = SensorValue[comp] + degrees;
	int difference = Variance(SensorValue[comp], degrees);

	while (true)
	{
		// Update the difference
		difference = Variance(SensorValue[comp], goal);

		// If we still need to go, go.
		if (abs(difference) > 0) // or some other thing
		{
			int pos = difference / abs(difference);

			motor[omniFL] = pos * 15;
			motor[omniFR] = pos * 15;
			motor[omniBL] = pos * 15;
			motor[omniBR] = pos * 15;
			wait10Msec(5);
		}
		else break;
	}
}
/*************************************************/


///////////////////////////////////////////////////
//           void SetSpin(int power)
///////////////////////////////////////////////////
//     Sets all 4 driving motors to power.
///////////////////////////////////////////////////
void SetSpin ( int power )
{
	motor[omniFL] = power;
	motor[omniFR] = power;
	motor[omniBL] = power;
	motor[omniBR] = power;
}
/*************************************************/


///////////////////////////////////////////////////
//  task SetWheels(bool goCarMode, bool applyMotors)
///////////////////////////////////////////////////
//   Switches the robot from tank mode to omnimode.
///////////////////////////////////////////////////
void SetWheels(bool goCarMode, bool applyMotors = true)
{
	if (goCarMode)
	{
		servo[rotFL] = FL_CAR;
		servo[rotFR] = FR_CAR;
		servo[rotBL] = BL_CAR;
		servo[rotBR] = BR_CAR;

		if (applyMotors)
		{
			wait10Msec(16);
			SetSpin(18);
			wait10Msec(46);
			SetSpin(0);
		}
	}
	else // set motors to auto no mouse mode
	{
		servo[rotFL] = OMNI;
		servo[rotFR] = OMNI;
		servo[rotBL] = OMNI;
		servo[rotBR] = OMNI;

		if (applyMotors)
		{
			wait10Msec(16);
			SetSpin(-18);
			wait10Msec(46);
			SetSpin(0);
		}
	}
}
/**************************************************/


///////////////////////////////////////////////////
// void SetMoveMath(int turn, int power, int rotate)
///////////////////////////////////////////////////
//    Drives the robot in a degree-based system.
// Now includes 'rotate' to account for joystick usage
///////////////////////////////////////////////////
void SetMoveMath ( int turn, int power, int rotate)
{
	float newPower = power * JOY_SCALE;

	float mathy = degreesToRadians(turn);

	float x = sin(mathy);
	float y = cos(mathy);


	motor[omniFR] = round(newPower * (x - y) + rotate);
	motor[omniBR] = round(newPower * (-x - y) + rotate);
	motor[omniFL] = round(newPower * (x + y) + rotate);
	motor[omniBL] = round(newPower * (-x + y) + rotate);
}
/*************************************************/


///////////////////////////////////////////////////
// void CompassDrive(int turn, int power, int time)
///////////////////////////////////////////////////
//   Drives the robot with autocorrections.
///////////////////////////////////////////////////
void CompassDrive (int turn, int power, int time, bool racist = false)
{
	for (int i = 0; i < time; i++)
	{
		SetMoveMath(turn, power);
		wait1Msec(time);
		if (racist && SensorValue[color] == WHITECOLOR) break;
	}
	SetSpin(0);
}

///////////////////////////////////////////////////
//          int Round(float input)
///////////////////////////////////////////////////
int Round (float num)
{
	return (int)(num + 0.5); // C-style casting
}
