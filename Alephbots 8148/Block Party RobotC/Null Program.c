#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     LeftDrive,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     RightDrive,    tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_3,    AutonomousDispenser,  tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TICKS_PER_INCH 120

void moveRobot(int LeftPower, int RightPower)	// subroutine for moving the robot
{
	motor[LeftDrive] = LeftPower;	// assign variable power level to left motor
	motor[RightDrive] = RightPower;	// assign variable power level to right motor
}

//void moveRobotOneRouteCoordinate(int power)
//{
//	nMotorEncoder[RightDrive] = 0;
//	nMotorEncoder[LeftDrive] = 0;
//	moveRobot(power, power);
//	while (abs(nMotorEncoder[RightDrive]) < TICKS_PER_INCH && abs(nMotorEncoder[LeftDrive]) < TICKS_PER_INCH)
//	//while (abs(nMotorEncoder[LeftDrive]) < TICKS_PER_INCH)
//	{
//		char displayString1[100];
//		char displayString2[100];
//		//sprintf(displayString1, "right = %d", abs(nMotorEncoder[RightDrive]));
//		//nxtDisplayCenteredTextLine(2, displayString1);
//		//sprintf(displayString2, "left = %d", abs(nMotorEncoder[LeftDrive]));
//		//nxtDisplayCenteredTextLine(3, displayString2);
//	}
//}

void moveRobotOneRouteCoordinate(int power)
{
	int differential; // Holds the encoder tick differential between right and left.
	int correction;  // Holds a calculated correction value.
	int correctedLeftPower;
	int correctedRightPower;

	// Reset the encoder tick counts.
	nMotorEncoder[RightDrive] = 0;
	nMotorEncoder[LeftDrive] = 0;

	while (abs(nMotorEncoder[LeftDrive]) < TICKS_PER_INCH && abs(nMotorEncoder[RightDrive]) < TICKS_PER_INCH)
	{
		differential = (abs(nMotorEncoder[RightDrive]) - abs(nMotorEncoder[LeftDrive]));  // Find the different between the left and right encoder.
		correction = (int) (differential * 0.1); // The correction value is a 10th of the differential.

		// Keep correction value within -10 and 10 (i.e. not more than a 10th of the power plus/minus).
		if (correction < -10)
		{
			correction = -10;
		}
		else if (correction > 10)
		{
		  	correction = 10;
		}

		correctedLeftPower = (power + correction); // Correct the left power value.

		// Keep the corrected left power value within -100 and 100
		if (correctedLeftPower < -100)
		{
			correctedLeftPower = -100;
		}
		else if (correctedLeftPower > 100)
		{
			correctedLeftPower = 100;
		}

		correctedRightPower = (power - correction); // Correct the right power value.

		// Keep corrected right power value within -100 and 100
		if (correctedRightPower < -100)
		{
			correctedRightPower = -100;
		}
		else if (correctedRightPower > 100)
		{
			correctedRightPower = 100;
		}

		// Drive the robot with the corrected power values.
		moveRobot(correctedLeftPower, correctedRightPower);
		wait1Msec(10);
	}
}

task main()
{
	int i;
	for (i = 0;(i < 40);i++)
	{
		moveRobotOneRouteCoordinate(50);
	}
	moveRobot(0, 0);
}
