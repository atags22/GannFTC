#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S4,     NorthSeeker,    sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     omniBR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     omniFR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     omniBL,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     omniFL,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#define JOY_SCALE 0.78	//scales down the values from the algorithm for getting motor values from the joystick because otherwise they are too large - is equal to 100 / 128 because 128 is the highest value the joystick has
#define JOY_THRESHOLD 30		//threshold for when joystick value is considered zero, because there is a good amount of noise in the joysticks
#define SQR(val) (val) * (val) // square function
#define JOY_NOISE 12 // Accounts for joystick noise
#define TC_Lim 5 //How fast joystick changes rotation. Lower means faster.

#define rotatespeed 5 //The higher this number is, the slower corrections to the direction happen.


task main()
{
	wait10Msec(50);
	int targetangle; //the angle to which we want the robot to turn
	float correction;
	int speed;
	int Direction;
	int targetcounter;
	float theta;
	float rotatechange; //the higher this number, the slower the effects from the joystick take place.
	Direction = SensorValue[NorthSeeker]; //baseline direction, number out of 360.
	targetangle = SensorValue[NorthSeeker];
	while(true)
	{

	getJoystickSettings(joystick); //update joystick position

			// Check for noise
		if ((sqrt(SQR(joystick.joy1_x1) + SQR(joystick.joy1_y1)) < JOY_THRESHOLD))
		{
			speed = 0;
		}
		else speed = (sqrt(SQR(joystick.joy1_x1) + SQR(joystick.joy1_y1)))/127; //set speed


		// Drive teleop



		if (abs(joystick.joy1_x2) > JOY_NOISE) // Check for noise
		{
			targetcounter ++;
		}
		if (targetcounter > TC_Lim)
			{
				targetangle += (joystick.joy1_x2/rotatechange);
			}
		correction = ((SensorValue[NorthSeeker] - targetangle)/(rotatespeed * 360));

		if (correction < JOY_NOISE)
			{
				correction = 0;
			}
		speed = (speed -= correction);

		if (joystick.joy1_x1 == 0)
			{
				//theta = joystick.joy1_y1 > 0 ? PI/2 : PI * 3/2; //Oron wrote this. It is neater so we will keep it, but my way on the next line is still cool.
				 //theta = (PI + ((PI/2) * (joystick.joy1_y1/abs(joystick.joy1_y1)))) - (PI/4); //because theta is undefined when joystick.joy1_x1 is 0 and I don't know how the nxt will handle it
				if (joystick.joy1y1 > 0)
					theta = PI/2;
				else theta = PI * 3/2;
			}
		else
			{
				theta = atan(joystick.joy1_y1/joystick.joy1_x1)/* - (PI/4))*/; //I don't know if we need the pi/4 yet. We will test both ways.
			}
		// Set the motors
		motor[omniFR] = (speed * sin(theta)) + correction;
		motor[omniBR] = (speed * cos(theta)) + correction;
		motor[omniFL] = (speed * -cos(theta)) + correction;
		motor[omniBL] = (speed * -sin(theta)) + correction;
		wait10Msec(5);
	}
}
