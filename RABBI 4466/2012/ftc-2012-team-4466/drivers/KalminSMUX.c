//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

/**********************************************************************\
*                                                                                                                                                                                                                                                                                       *
* PROGRAM: Heading                                                                                                                                                                      *
* VERSION: 1                                                                                                                                                                                                                                    *
* PURPOSE: This program integrates gyro and compass readings using a  *
*          Kalman filter to get a more accurate value for heading     *
* AUTHOR: Ben C.                                                      *
* BASED ON WORK BY:      Aswin Bouwmeester                                      *
* DATE:          April 2011                                                                                                                                                                               *
*                                                                                                                                                                                                                                                                                 *
* LICENSE: GNU GPL V3 2011
\**********************************************************************/

/*
variance for the _yro sensor for different sample sizes

N   T   var
1         5       0,222
2         10    0,144
3         15    0,123
4         20    0,119
5         25    0,114
6         30    0,08801
8         40    0,093
10      50      0,078
*/


//#pragma systemFile


// MOUNTING can be set to - if the compass or the gyro is mouned upside down
#ifndef MOUNTING
#define MOUNTING
#endif

int compassoffset;

#ifndef KALMINSMUX
#define KALMINSMUX
#endif
#define HEADING_DISPLAY
bool undisturb = false;
        void compasscal() {
          compassoffset = CompassReading();
        }

        int compassread (){
          int read = CompassReading() - compassoffset;
          if ( read < 0 || read >= 360) {
          read = ((read < 0) ? (read + 360):(read - 360));
          }
  return read;
}

float meanSensorValuegyro( int interval, int N);
int heading=-1;
int headingwneg = -1;

bool kalmindebugdisplay = true;


int __index = 0;
float _offset;

task getheading() {

  float
  var_compass = 0.6,
  var_gyro=0.119,
  var_filter_predicted,
  var_filter_updated,
  kalman_gain,
  compass_measured,
  compass_predicted,
  compass_updated,
  gyro_measured,
  time_span,
  ;

  long
  time_start,
  time_end
  ;

  bool
  disturbed = false;
  bool cycled = false;


  // get the gyro offset
  _offset=meanSensorValuegyro(0,100);  //Finds gyro Offset
  compasscal();             // Callibrates Compas so that 0 is current facing

  // initialise the filter;
  compass_updated=compassread();
  var_filter_updated=0;

  // Run the filter forever;
  while (true)
  {
    // get time span;
    time_end=nPgmTime;
    time_span=((float)(time_end-time_start))/1000.0;
    if (time_span<=0) time_span=0.02; // this is to compensate for wrapping around the nPgmtime variable;
      time_start=nPgmTime;

    // get measurements from sensors
    // (when changing the sample size of the gyro, one must also change the variance)
    compass_measured= compassread();                  // read the compass
    if (cycled){
      gyro_measured=MOUNTING (meanSensorValuegyro(5,4)- _offset);   // read the gyro
    }
    else {
      gyro_measured = 0;
      cycled = true;
    }
    //writeDebugStreamLine(""+time_span);
    // predict;
    compass_predicted=compass_updated+ (time_span*gyro_measured);  // predict the next reading on the basis of the gyro
    var_filter_predicted=var_filter_updated+var_gyro;           // Decides of a varience for the filter based on the previous varience and the gyro varience
    // heading must be between 0 and 359
    if (compass_predicted < 0) compass_predicted+=360;          // keeps the compass value between 0 and 360
      if (compass_predicted>=360) compass_predicted-=360;

    if (abs(compass_predicted-compass_measured) > 180) {
      if (compass_predicted>compass_measured) {
        compass_predicted-=360;
        } else {
        compass_measured-=360;
      }
    }

    // Detect _compass disturbance;
    if (abs(compass_predicted-compass_measured)>8 *
    	sqrt(var_filter_predicted)) {/*&& abs (360 -(compass_predicted-compass_measured)) > 3 * sqrt(var_filter_predicted)*/

      disturbed=true;  // desides whether or not the compass is disturbed or not
    }
    else {
      disturbed=false;
    }

    getjoystickts();
     if (undisturb){
       disturbed = false;
     }
    // get Kalman gain;
    if (disturbed)
      kalman_gain = 0; // if the compass is disturbed used only the gyro
    else
      kalman_gain=var_filter_predicted/(var_filter_predicted+var_compass); //otherwise the kalman gain is creates a percent of compass and percent of gyro

    // update;
    compass_updated= compass_predicted + (kalman_gain * (compass_measured-compass_predicted)); // uses previously computed kalmin gain to calculate new heading
    var_filter_updated=var_filter_predicted + (kalman_gain*(var_compass-var_filter_predicted)); // desides on a new varience for the filter based on the kalman gain

    // make result available gobally
    heading = compass_updated;
    if (heading > 270){
      headingwneg = heading - 360;
    }
    else if (heading < -270){
      headingwneg = heading + 360;
    }
    else {
      headingwneg = heading;
    }



    // display informatin about filter

    if (kalmindebugdisplay){                                                // output debug information
        __index++;
      nxtDisplayTextLine(0,"Heading filter");
      nxtDisplayTextLine(1,"Heading  : %3.0f",compass_updated);
      nxtDisplayTextLine(2,"Compass  : %4f",  compass_measured);
      nxtDisplayTextLine(3,"Variance : %6f", var_filter_updated);
      nxtDisplayTextLine(4,"Kalmin: %1f  ",kalman_gain);
      nxtDisplayTextLine(5, ((disturbed) ? "disturbed":"not disturbed"));
      nxtDisplayTextLine(6, "offset: %d", compassoffset);
      nxtDisplayTextLine(7, "g-o: %f", _offset);
    }
    // wait for next iteration;
    wait1Msec(0);


  }
}

// get a mean sensor value from specified number of samples
float meanSensorValuegyro(int interval, int N)
{
  float som=0;
  for(int i=0;i<N;i++)
  {
    som+=GyroReading();
    wait1Msec(interval);
  }
  som=som/N;
  return som;
}

void startkalmin (){
  calibrategyro();
  compasscal();
  StartTask(getheading);
}

void stopkalmin (){
  StopTask(getheading);
}

void resetkalmin(){
  stopkalmin();
  startkalmin();
}

void findgyrooffset () {
  StopTask(getheading);
  _offset = ((_offset * 100) + (meanSensorValuegyro(0,100) * 20)) /120;
  StartTask(getheading);
}
