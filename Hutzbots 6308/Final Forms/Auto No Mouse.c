#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     BR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     FR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BlockatorTL,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     PullBottom,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     BL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     FL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C1_1,     BlockatorTR,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    PullTop,              tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_2,    BlockDrop,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    BlockatorBL,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    BlockatorBR,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_5,    FlagRotater,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///////////////////////////////////////////////////
// 4608 Multi-Vector Auto No Mouse Assault Mode //
/////////////////////////////////////////////////

#include "Youtilities.c"
#include "JoystickDriver.c"
#include "Autonomousechooser.c"


//////////////
// Driving //
////////////
// Six stages,
long stages[7];
float angles[7];
int speeds[7];

#define TURN_45  900
#define PATROL_LENGTH 6900
#define ACROSS_BASKETS 5100
#define RAMP_NORMAL 3200
#define RAMP_HALF 1700
#define RAMP_DOUBLE 3800

//////////////////////////////////////////////////
//              Block Placing
//////////////////////////////////////////////////
void stoppingPlaceBlock()
{
	Stop();
	wait1Msec(700); // originally 280, originally 280 + 400
	servoChangeRate[BlockDrop] -= 3;
	servo[BlockDrop] -= 70;
	wait1Msec(300);
	servo[BlockDrop] += 70;
	servoChangeRate[BlockDrop] += 3;
}

// What stage in the program the robot is at
ubyte Stage = 0;

void Initialize()
{
	servo[BlockDrop] = 174;
	// Initial values.
	for (int i = 0; i < 6; i++)
	{
		angles[i] = PI / 2.0;
		stages[i] = 0;
	}
	int ramp;
	if (rampType == 1)      ramp = RAMP_HALF;
	else if (rampType == 2) ramp = RAMP_NORMAL;
	else                    ramp = RAMP_DOUBLE;

	if (isCornerMode)
	{
		stages[0] = 7320;
		speeds[0] = 80;

		stages[1] = PATROL_LENGTH;
		speeds[1] = 60;

		stages[2] = 1;
		speeds[2] = 80;

		stages[3] = ACROSS_BASKETS;
		speeds[3] = 80;

		stages[4] = ramp;
		speeds[4] = 100;

		speeds[5] = 0;

		if (isLeftTurn)
		{
			angles[0] = 4.40482 - PI;
			angles[1] = -1; // backwards
			angles[3] = -1; //right
		}
		else // right
		{
			angles[0] = 3.4491 - PI;
			angles[1] = 0; // forward {?}
			angles[3] = -1; // left
		}

	}
	else // side start.
	{
		stages[0] = 1000;
		speeds[0] = 80;

		angles[1] = TURN_45;
		speeds[1] = 60;

		stages[2] = PATROL_LENGTH;
		speeds[2] = 60;

		stages[3] = 1;
		speeds[3] = 80;

		stages[4] = ACROSS_BASKETS;
		speeds[4] = 80;

		stages[5] = ramp;
		stages[5] = 100;

		speeds[5] = 0;
	}
}


//////////////////
// task main() //
////////////////
task main()
{
	AutoNoMouseGUI();
	Initialize();
	waitForStart();

	bool armed = false;
	if (isCornerMode && !isLeftTurn)
	{
		armed = true;
		motor[BlockatorTL] = motor[BlockatorTR] = 100;
		wait1Msec(1000); extraTime -= 1;
	}
	if (extraTime > 0) wait1Msec(extraTime * 1000);

  nMotorEncoder[FL] = nMotorEncoder[FR] =
  nMotorEncoder[BL] = nMotorEncoder[BR] = 0;

	//return;

//////////////////////////////////////////////////
//               Initialization
//////////////////////////////////////////////////
// Set things up, possibly determine red/blue,
// and stuff. Set initial speed towards the thing
//////////////////////////////////////////////////

// Set up red/blue/team settings
// Set initial speed and stuff

//////////////////////////////////////////////////
//                  Looping
//////////////////////////////////////////////////
	while (true)
	{
		///////////////////////////
		// Handle Special cases //
		/////////////////////////
		if (((Stage == 1 && isCornerMode) || (Stage == 2 && !isCornerMode))
				&& SensorValue(IR) == 5)
		{
			Stage++; stages[2] = stages[1] - abs(nMotorEncoder[FL]);
			stoppingPlaceBlock();
		}
		else if (speeds[Stage] == 0)
		{
			Stop();
			return;
		}

		/////////////////////
		// Handle driving //
		///////////////////
		if (Stage == 1 && !isCornerMode) // the turning stage
		{
			if (abs(nMotorEncoder[FL]) < stages[1])
			{
				// Set the motors to rotate to the speed.
				motor[FR] = motor[BR] = speeds[1];
				motor[BL] = motor[FL] = -speeds[1];
			}
			else // we have rotated succesfully
			{
				Stop(); wait10Msec(10);
				nMotorEncoder[FL] = 0;
				Stage++;
			}
		}
		else // angle driving, regular
		{
			if (abs(nMotorEncoder[FL]) < stages[Stage]) // && nMotorEncoder[FR] < desiredDistance)
			{
				// Set the mecanum wheels to drive at the speed/angle.
				driveMeccanum(speeds[Stage], angles[Stage], 1, 0);
			}
			else // we have reached the required distance
			{
				Stop(); wait10Msec(10);
				nMotorEncoder[FL] = 0;
				Stage++;
			}
		} // angle
	} // while
} // main



/*
		/////////////////////////
		//     Switch case
		/////////////////////////
		switch (Stage)
		{
			// Approach the center
			/////////////////////////
			case 1:
				// Should go forward till the turning point
				stageDrive(STAGE_1, 50);
				break;

			// Rotate left or right
			///////////////////////
			case 2:
				stageRotate(TURN_45, 50, true);
				break;

			// Ready bracket length
			//////////////////////
			case 3:
				stageDrive(STAGE_3, 70);
				if (SensorValue[IR] == INFRONT_IR)
				{
					blockDistance = desiredDistance - abs(nMotorEncoder[FL]);
					motor[FL] = motor[FR] = motor[BL] = motor[BR] = 0;wait10Msec(10);
					nMotorEncoder[FL] = 0;
					Stage++;
				}
				break; // In case we're in IR

			// Drop the block inside
			/////////////////////////
			case 4:
				stoppingPlaceBlock();
				Stage++;
				continue; // patrol to the end

			// Patrol to the end
			////////////////////
			case 5:
				// get the distance based on stoppedBlock.
				// I wouldn't mind a switch here but I don't care.
				// stoppedblock => patrolDistance
				stageDrive(blockDistance, 70);
				break;

			// Go sideways (right)
			//////////////////////
			case 6:
				stageSide(STAGE_6, PI, 50);
				break;

			// Go backwards
			///////////////
			case 7:
				stageSide(STAGE_7, PI/2.0, 70);
				break;

			// Park on ramp
			///////////////
			case 8:
				Stop();
				return;
		}

		//////////////////////////////////////////////////
		// Apply driving to the wheels for this stage
		//////////////////////////////////////////////////

		if (driveType == 0)
		{
			if (abs(nMotorEncoder[FL]) < desiredDistance)
			{
				// Set the motors to rotate to the speed.
				motor[FR] = motor[BR] = desiredSpeed;
				motor[BL] = motor[FL] = -desiredSpeed;
			}
			else // we have rotated succesfully
			{
				Stop(); wait10Msec(10);
				nMotorEncoder[FL] = 0;
				Stage++;
			}
		}
		else if (driveType == 1) // Regular driving stage
		{
			if (abs(nMotorEncoder[FL]) < desiredDistance) // && nMotorEncoder[FR] < desiredDistance)
			{
				// Set the mecanum wheels to drive at the speed/angle.
				driveMeccanum(desiredSpeed, driveAngle, 1, 0);
			}
			else // we have reached the required distance
			{
				motor[FL] = motor[FR] = motor[BL] = motor[BR] = 0;wait10Msec(10);
				nMotorEncoder[FL] = 0;
				Stage++;
			}
		}

	} // end while
} // end main
*/
