#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     comp,           sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     color,          sensorCOLORFULL)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     omniBR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     omniFR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     omniBL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     omniFL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     lift,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     nomotorhere,   tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    rotFL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    rotFR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    rotBR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    rotBL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    armBase,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    armClaw,              tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     Includes and definitions
//////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  // Include file to "handle" the Bluetooth messages.
#include "RobotFunctions.h"

#define CLAWBASE 0 // TODO: The angle that the claw will be at by default.
#define WHITE 0 // The value our sensor is looking for.
#define DIST(x,y) abs((x)) - abs((y))

int RingAngle = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Autonomous Methods
//////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////
//             void initializeRobot()
///////////////////////////////////////////////////
// Used at the beginning of the phase to set servos
///////////////////////////////////////////////////
void initializeRobot()
{
	// Setup wheel servos - true is tankmode
	SetWheels(true, false);

	// Set motor speeds just in case or something
	nMotorPIDSpeedCtrl[omniBL] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[omniBR] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[omniFL] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[omniFR] = mtrSpeedReg;
}

///////////////////////////////////////////////////
//        void WaitForColor(int timeout)
///////////////////////////////////////////////////
//   Waits for milleseconds or for color sensors
///////////////////////////////////////////////////
void WaitForColor(int timeout, int color = 14)
{
	for (int i = 0; i < timeout; i++)
	{
		wait1Msec(1);
		if (SensorValue[color] == color) break;
	}
}

///////////////////////////////////////////////////
//		void TurnToDirection(int angleToRotate)
///////////////////////////////////////////////////
// Turns the robot to face a specific angle.
// Accurate within a few degrees if we're lucky.
///////////////////////////////////////////////////
void TurnToDirection(int angleToRotate)
{
	int requiredAngle = Variance(SensorValue[comp], angleToRotate) + SensorValue[comp];

	int sign = abs(angleToRotate) >= angleToRotate ? 1 : -1;

	SetWheels(sign*20);

	for (int i = 0; i < abs(angleToRotate)*10; i++) // approximate how long we need to rotate
	{
		wait10Msec(1);
		if (abs(Variance(SensorValue[comp], requiredAngle)) < 3) // turn is ok
		{
			SetWheels(0);
			return;
		}
	}
	SetWheels(-sign * 20);
	wait1Msec(200);
	SetWheels(0);
}

///////////////////////////////////////////////////
//		void tDriveCompass(int rDriveAngle, int delay)
///////////////////////////////////////////////////
// Turns the robot to face a specific angle.
// Accurate within a few degrees if we're lucky.
///////////////////////////////////////////////////
void tDriveCompass(int rDriveAngle, int speed, int delay)
{
	int angleToDriveIn = rDriveAngle + SensorValue[comp];

	for (int i = 0; i < delay; i++)
	{
		int newAngleToDriveIn = Variance(SesorValue[comp], angleToDriveIn);
		SetMoveMath(newAngleToDriveIn);
		wait10Msec(1);
	}
}

/*////////////////////////////////////////////////////////////////////////////////////////////////////
//                                            Main Task
//////////////////////////////////////////////////////////////////////////////////////////////////////
//								The robot tries to place a ring upon the proper peg on the board.
//////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                          Initialization
//////////////////////////////////////////////////////////////////////////////////////////////////////
	initializeRobot();

	waitForStart(); // Wait for the beginning of autonomous phase.

	// Set up the angle for driving and for the rings.
	UserAngle = SensorValue[comp] - 90;
	RingAngle = SensorValue[comp] + 45;

	// Set up the arm and grabber.
	tSetupLift();

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     Begin Driving to Rings
//////////////////////////////////////////////////////////////////////////////////////////////////////

	SetSpin(80); // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Drive in tank mode until we have hit the middle color strip
	WaitForColor(4000, 17);
	WaitForColor(2000, 14);
	SetWheels(false, true); // go back to omnimode
	tTurnDegrees(45);

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     Check for directions
//////////////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////
	//                  Go Right
	///////////////////////////////////////////////////
	if (SensorValue[ir] > 4) // right
	{
		// Go right until hit sensor
		SetMoveMath(0, 20, 0);
		WaitForColor(2800);
	}
	///////////////////////////////////////////////////
	//                   Go Left
	///////////////////////////////////////////////////
	else if (SensorValue[ir] < 2) // left
	{
		// Crossing over two color bands
		SetMoveMath(180, 20);
		WaitForColor(4600);
		wait10Msec(100); // so we don't get multiple color indications in a row
		WaitForColor(1200);
	}
	///////////////////////////////////////////////////
	//                  Go Center
	///////////////////////////////////////////////////
	else // centered
	{
		SetMoveMath(180, 20, 1200);
		WaitForColor(800);
	}
	///////////////////////////////////////////////////
	//                Apply Brakes on color
	///////////////////////////////////////////////////
	SetSpin(0);

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                Apply and finish up
//////////////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////
	//           Deposit rings on the hooks
	///////////////////////////////////////////////////
	SetMoveMath(90, 15);
	motor[lift] = -20;
	wait1Msec(1500);
	motor[lift] = 0;


	///////////////////////////////////////////////////
	//              Move back, finish up
	///////////////////////////////////////////////////
	SetMoveMath(270, 15);
	wait1Msec(2000);
	SetSpin(0);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
//							New Auto No Mouse Mode: Visiting all four corners of the field
////////////////////////////////////////////////////////////////////////////////////////////////////*/
task main
{
	// We assume we start in the bottom left corner.
	int angle = 0;
	for (int i = angle; i < 360; i += 90)
	{
		SetMoveMath(i, 40);
		wait1Msec(3000);
	}
}
