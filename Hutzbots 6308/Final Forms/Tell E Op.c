#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     BR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     FR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BlockatorTL,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     PullBottom,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     BL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     FL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C1_1,     BlockatorTR,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    PullTop,              tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_2,    AutoBlockator,        tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    BlockatorBL,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    BlockatorBR,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_5,    FlagRotater,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// SeniorCodeItIs
//////////////////////////
// Hutzbots Teleop Code	//
//         A            //
//        / \           //
//       /   \          //
// <----+-----+---->    //
//  \  /       \  /     //
//   \/         \/      //
//   /\         /\      //
//  /  \       /  \     //
// <----+-----+---->    //
//       \   /          //
//        \ /           //
//         V            //
//////////////////////////

//////////////////////////////////////
// Our opportunites are televised. //
////////////////////////////////////
// Alex Tagieri (math/arm),
// Joshua Hailman (form, appearance),
// Hodaya Propp (Mathymath/flag)
////////////////////////////////


////////////////////////////
// Open debugger windows //
//////////////////////////
//#pragma DebuggerWindows("joystickSimple")


//////////////////////////
// Octothorpe Includes //
////////////////////////
#include "Youtilities.c"
#include "JoystickDriver.c"


//////////////////////////////////
// Octothorpe Define Constants //
////////////////////////////////
// Driving: Scale the joystick to 100
#define JOY_SCALE 0.77
// Driving: How far off from 0,0 the joystick
// must be to register turning
#define JOY_NOISE 11
// Buttons:  Press Timer maximum value
#define BUTTON_MAX 50


////////////////////////
// Driving Variables //
//////////////////////
// Scale driving speed with buttons
float DrivingScale = 1;
// How much to rotate the robot
int Rotate;
// Vector from the joystick
float Theta, Speed;
// Convert 127 to 100
float JoyMotorConverter = 100.0 / 127;

//////////////////////////
// Operating variables //
////////////////////////
int BlockatorTopPower = 0;
int BlockatorBottomPower = 127;

////////////////////// ////////////////////////////////////////////////
// Button Counters // // These make sure our buttons work properly. //
//////////////////// ////////////////////////////////////////////////
byte cLiftTop = 0;
byte cAutoBlockinator = 0;
byte cFlagRotator = 0;


///////////////////////////////////
// Text summary of the controls //
/////////////////////////////////

//////////////////////////////
// Joystick 1: Driver Gabe //
////////////////////////////
// L joy: drive robot omniwheel to angle
// R joy: rotate robot around center
// Button 5: Speed to 0.5
// Button 7: Speed to 0.25
// Button 5&7: Speed to 1.3
// Button 9: Toggle user filter
// Button 10: Reset user filter
///////////////////////

////////////////////////////////
// Joystick 2: Operator Alex //
//////////////////////////////
// Left joy: Move the lift base motor
// Right joy: Move the lift top servo
// Button 4: Latch on pullup bar moves one way
// Button Two: Latch on pullup bar moves the other way.
// Button LB: Pullup mech moves one way.
// Button RB: Pullup mech moves the other way.
// Button 3: Get blocks (continuous rotation on)
// Button 5: Get blocks (continuous rotation off)
///////////////////////


////////////////// //////////////////////
// task main() // // Main teleop code //
//////////////// //////////////////////
task main()
{
	// Infinite loop
	while (true)
	{
		///////////////////////
		// Operation stages //
		/////////////////////
		// 1. Update joystick
		// 2. Get motor adjustments
		// 3. Set motors for driving
		// 4. Operate Blockator
		// 5. Move AutoBlockator
		// 6. Operate the lift
		// 7. Operate the flag raiser
		////////////////////

		/////////////////////////
		// 1. Update joystick //
		///////////////////////
		getJoystickSettings(joystick);


		///////////////////////////////
		// 2. Get motor adjustments //
		/////////////////////////////
		// Adjust DrivingScale to factor into motor speed.
		if (joy1Btn(5) && joy1Btn(7)) DrivingScale = 1.3;
		else if (joy1Btn(5))  /* 5 */ DrivingScale = .7;
		else if (joy1Btn(7))  /* 7 */ DrivingScale = .3;
		else            /* Neither */ DrivingScale = 1;


		////////////////////////////////
		// 3. Set motors for driving //
		//////////////////////////////
		// Determine if controls are above noise level
		Speed = sqrt(sqr(joystick.joy1_x1) + sqr(joystick.joy1_y1));
		if (Speed > JOY_NOISE)
		{
			// Get the angle of the joystick
			Theta = atan2(joystick.joy1_y1, joystick.joy1_x1);
		}
		else Speed = 0;

		///////////////
		// Rotation //
		/////////////
		if (abs(joystick.joy1_x2) > JOY_NOISE)
		{
			Rotate = joystick.joy1_x2;
		}
		else // No rotation is detected
		{
			Rotate = 0;
		}

		//////////////////////////
		// Driving Application //
		////////////////////////
		driveMeccanum(Speed, Theta, DrivingScale, Rotate);


		///////////////////////////
		// 4. Operate Blockator //
		// Blockator top
		if (joy1Btn(2)) BlockatorTopPower = 25;
		else if (joy1Btn(4)) BlockatorTopPower = -25;
		else if (joy1Btn(6) && abs(joystick.joy1_y2) > JOY_NOISE)
		{
			BlockatorTopPower = joystick.joy1_y2 * JoyMotorConverter * .3;
		}
			else if (joy1Btn(10))
			BlockatorTopPower = -100;

	else if (joy1Btn(11))
 			BlockatorTopPower = 100;

		else BlockatorTopPower = 0;

		motor[BlockatorTL] = motor[BlockatorTR] = BlockatorTopPower;



		// Blockinator bottom
		if (joy1Btn(1))
		{
			BlockatorBottomPower = 60;
		}
		else if (joy1Btn(3))
		{
			BlockatorBottomPower = 185;
		}
		else if (joy1Btn(8) && abs(joystick.joy1_y2) > JOY_NOISE)
		{
			BlockatorBottomPower = 127 + (joystick.joy1_y2 * .5);
		}
		else BlockatorBottomPower = 127;

		servo[BlockatorBL] = servo[BlockatorBR] = BlockatorBottomPower;


		//////////////////////////////
		// 5. Move AutoBlockinator //
		////////////////////////////
		if (joy2Btn(4))
		{
			if (cAutoBlockinator > 0)
				cAutoBlockinator--;
			else
			{
				cAutoBlockinator = 2;
				servo[AutoBlockator] += 1;
			}
		}
		else if (joy2Btn(3))
		{
			if (cAutoBlockinator > 0)
				cAutoBlockinator--;
			else
			{
				cAutoBlockinator = 2;
				servo[AutoBlockator] -= 1;
			}
		}
		else cAutoBlockinator = 0;


		//////////////////////////
		// 6. Operate the lift //
		////////////////////////
		// Left stick: bottom
		if (!joy2Btn(6))
		{
			if (!joy2Btn(6) && abs(joystick.joy2_y1) > JOY_NOISE)
			{
				motor[PullBottom] = joystick.joy2_y1 * JoyMotorConverter;
			}
			else motor[PullBottom] = 0;

			// Right stick: top
			if (!joy2Btn(6) && abs(joystick.joy2_y2) > JOY_NOISE)
			{
				servo[PullTop] = 127 - joystick.joy2_y2;
			}
			else servo[PullTop] = 127;
		}


		/////////////////////
		// 7. Flag raiser //
		///////////////////
		else // joy2Btn(6)
		{
			if (abs(joystick.joy2_y2) > JOY_NOISE)
			{
				motor[Flag] = joystick.joy2_y2 * JoyMotorConverter;
			}
			else motor[Flag] = 0;
		}

		wait1Msec(5);

	} // while
} // main
