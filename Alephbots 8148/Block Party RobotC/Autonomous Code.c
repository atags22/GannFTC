#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     LeftDrive,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     RightDrive,    tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_3,    AutonomousDispenser,  tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TICKS_PER_INCH 120

#include "JoystickDriver.c"

void moveRobot(int LeftPower, int RightPower)	// subroutine for moving the robot
{
	motor[LeftDrive] = LeftPower;	// assign variable power level to left motor
	motor[RightDrive] = RightPower;	// assign variable power level to right motor
}

void turnLeft(int degrees)
{
	int degreesToTurn = degrees;
	float degreesSoFar = 0;
	int initialTurnReading = SensorValue[Gyro];

	moveRobot(-75, 75);

	while (abs(degreesSoFar) < abs(degreesToTurn))
	{
		wait1Msec(10);
		int currentGyroReading = SensorValue[Gyro] - initialTurnReading;
		degreesSoFar = (degreesSoFar + (currentGyroReading * .01));
	}

	moveRobot(0, 0);
}

void turnRight(int degrees)
{
	int degreesToTurn = -degrees;
	float degreesSoFar = 0;
	int initialTurnReading = SensorValue[Gyro];

	moveRobot(75, -75);

	while (abs(degreesSoFar) < abs(degreesToTurn))
	{
		wait1Msec(10);
		int currentGyroReading = SensorValue[Gyro] - initialTurnReading;
		degreesSoFar = (degreesSoFar + (currentGyroReading * .01));
	}

	moveRobot(0, 0);
}

void moveRobot(int LeftPower, int RightPower)	// subroutine for moving the robot
{
	motor[LeftDrive] = LeftPower;	// assign variable power level to left motor
	motor[RightDrive] = RightPower;	// assign variable power level to right motor
}

void moveRobotOneRouteCoordinate(int power)
{
	int differential; // Holds the encoder tick differential between right and left.
	int correction;  // Holds a calculated correction value.
	int correctedLeftPower;
	int correctedRightPower;

	// Reset the encoder tick counts.
	nMotorEncoder[RightDrive] = 0;
	nMotorEncoder[LeftDrive] = 0;

	while (abs(nMotorEncoder[LeftDrive]) < TICKS_PER_INCH && abs(nMotorEncoder[RightDrive]) < TICKS_PER_INCH)
	{
		differential = (abs(nMotorEncoder[RightDrive]) - abs(nMotorEncoder[LeftDrive]));  // Find the different between the left and right encoder.
		correction = (int) (differential * 0.1); // The correction value is a 10th of the differential.

		// Keep correction value within -10 and 10 (i.e. not more than a 10th of the power plus/minus).
		if (correction < -10)
		{
			correction = -10;
		}
		else if (correction > 10)
		{
		  	correction = 10;
		}

		correctedLeftPower = (power + correction); // Correct the left power value.

		// Keep the corrected left power value within -100 and 100
		if (correctedLeftPower < -100)
		{
			correctedLeftPower = -100;
		}
		else if (correctedLeftPower > 100)
		{
			correctedLeftPower = 100;
		}

		correctedRightPower = (power - correction); // Correct the right power value.

		// Keep corrected right power value within -100 and 100
		if (correctedRightPower < -100)
		{
			correctedRightPower = -100;
		}
		else if (correctedRightPower > 100)
		{
			correctedRightPower = 100;
		}

		// Drive the robot with the corrected power values.
		moveRobot(correctedLeftPower, correctedRightPower);
		wait1Msec(10);
	}
}

bool isBeaconInRange(tSensors irSensor)	// subroutine that determines whether IR beacon is in range
{
	wait1Msec(1);
	int ir = SensorValue[irSensor];	// defines integer that returns current sensor value
	wait1Msec(1);
	if (ir == 0)	// no beacon detected
	{
		return false;
	}
	else	// beacon detected
	{
		return true;
	}
}

void DispenseBlock()	// subroutine to dispense block into bin with IR beacon, will be called when robot reaches box with beacon
{
	servo[AutonomousDispenser] = 150;	// run motor to dispense block
	wait1Msec(400);	// replace 3000 with amount of time it takes to dispense
	servo[AutonomousDispenser] = 0;	// stop motor after dispensing
}

task main()
{
	waitForStart();
	servo[AutonomousDispenser] = 0;
	wait1Msec(1000);
	for (i = 0;(i < 50);i++)
	turnRight(45);
	long i;
	for (i = 0;(i < 50);i++)
	{
		moveRobotOneRouteCoordinate(100, 100);
		if (isBeaconInRange(irSensor) == true)
		{
			int sector;
			if (i < 33)
			{
				sector = 5;
			}
			else
			{
				sector = 6;
			}
			if (SensorValue[irSensor] == sector)	// robot has reached the desired sector
			{
				if (sector == 6)
				{
					wait1Msec(100);
				}
				DispenseBlock();
			}
		}
	}
	turnLeft(90);
	wait1Msec(10);
	for (i = 0;(i < 35);i++)
	{
		moveRobotOneRouteCoordinate(100, 100);
	}
	turnLeft(70);
	for (i = 0;(i < 50);i++)
	{
		moveRobotOneRouteCoordinate(100, 100);
	}
	moveRobot(0, 0);
}

void moveRobotOneRouteCoordinate(int power)
{
	int differential; // Holds the encoder tick differential between right and left.
	int correction;  // Holds a calculated correction value.
	int correctedLeftPower;
	int correctedRightPower;

	// Reset the encoder tick counts.
	nMotorEncoder[RightDrive] = 0;
	nMotorEncoder[LeftDrive] = 0;

	while (nMotorEncoder[LeftDrive] < TICKS_PER_INCH && nMotorEncoder[RightDrive] < TICKS_PER_INCH)
	{
		differential = (nMotorEncoder[RightDrive] - nMotorEncoder[LeftDrive]);  // Find the different between the left and right encoder.
		correction = (int) (differential * 0.1); // The correction value is a 10th of the differential.

		// Keep correction value within -10 and 10 (i.e. not more than a 10th of the power plus/minus).
		if (correction < -10)
		{
			correction = -10;
		}
		else if (correction > 10)
		{
		  	correction = 10;
		}

		correctedLeftPower = (power + correction); // Correct the left power value.

		// Keep the corrected left power value within -100 and 100
		if (correctedLeftPower < -100)
		{
			correctedLeftPower = -100;
		}
		else if (correctedLeftPower > 100)
		{
			correctedLeftPower = 100;
		}

		correctedRightPower = (power - correction); // Correct the right power value.

		// Keep corrected right power value within -100 and 100
		if (correctedRightPower < -100)
		{
			correctedRightPower = -100;
		}
		else if (correctedRightPower > 100)
		{
			correctedRightPower = 100;
		}

		// Drive the robot with the corrected power values.
		moveRobot(correctedLeftPower, correctedRightPower);
		wait1Msec(10);
	}
}
