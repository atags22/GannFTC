#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     comp,           sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     color,          sensorI2CHiTechnicColor)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     omniBR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     omniFR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     omniBL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     omniFL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     lift,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     nomotorhere,   tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    rotFL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    rotFR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    rotBR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    rotBL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    armClaw,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     Includes Files
//////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"
#include "RobotFunctions.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     #Definitions
//////////////////////////////////////////////////////////////////////////////////////////////////////

#define SQR(x) ((x) * (x)) // Because ROBOTC needs a squaring operand/command

// # Joystick Values
#define JOY_SCALE 0.78 // Scales down motor values from joystick: 128 -> 100
#define JOY_NOISE 12 // Accounts for joystick noise

// # Arm Servo Values
#define A_SHAKE_AMPLITUDE_T 3 // How far the servo will rotate back and forth when in shake mode
#define A_C_CONTROLTILT 7 // how far the arm will rotate when the button is pressed
#define A_C_REGTILT 127 // the default value of the servo

// # Button Counter Values
#define BUTTON_TIMER 65 // for not looping the button commands

/*************************************************/

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                   Variables and cButtonCounter s
//////////////////////////////////////////////////////////////////////////////////////////////////////

// Lift Variables
float LiftScale = 1; // 1.0, 0.5, 1.2

// Arm Variables
byte cArmCenter = 0; // toggle arm from flat to tilted
byte cArmJoystick = 0; // A joystick counter ftw
byte cArmVibrate = 0; // for the button of lift vibrate
bool ShakeForward = true; // for the earthquake function


// Filter Variables
byte cFilterReset = 0; // Button for filter reset
byte cFilterToggle = 0; // Button for filter toggle
bool Filtered = false; // whether the filter is active


// Driving Values
float DrivingScale = 1; // 1.0, 0.5, 0.25
byte cModeSwitch = 0; // button: switch driving modes
//byte cReverseSet = 0; // button: spins the wheels perfectly backwards for a second.
byte ReverseCount = 0; // amount of time before motors should stop reversing.
bool MagicMode = false; // whether the wheels are turned like a car
float MoveX = 0, MoveY = 0; // used for both types of driving
int rotate = 0; // also used in driving

// User-Filter Values
byte cTurnToUser = 0; // Turns the robot to face the user (kinda a debug thing).
byte cTurnToRings = 0; // Turns the robot to be facing the ring dispenser
/*
int ufRotateAngle = 0; // Used instead of MoveX and MoveY
int ufSpeed = 0; //       Used instead of MoveX and MoveY*/

/**************************************************/

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                 O Glorious task main()
//                                   How I adore(thee);
//////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
	//int RingAngle = UserAngle + 45; // works for now.
	SetWheels(false, false);
	//bDisplayDiagnostics = false;
	//nxtDisplayCenteredTextLine(0, "S: %d,%d,%d,%d", nMotorEncoder[omniBL], nMotorEncoder[omniBR], nMotorEncoder[omniFL], nMotorEncoder[omniFR]);
	while (true)
	{
		///////////////////////////////////////////////////
		//                 Joystick set
		///////////////////////////////////////////////////
		// I think it's obvious what this does. WeEeEeEeE
		///////////////////////////////////////////////////

		// Get the joystick settings
		getJoystickSettings(joystick);
		//nxtDisplayCenteredBigTextLine(1, "%d,%d,%d,%d", nMotorEncoder[omniBL], nMotorEncoder[omniBR], nMotorEncoder[omniFL], nMotorEncoder[omniFR]);

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Driving
//////////////////////////////////////////////////////////////////////////////////////////////////////
//  The robot drives with omniwheels, two modes, a user filter, and a lot of math. Thanks to Alex.
//////////////////////////////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////
		//             Set Drivingscale
		///////////////////////////////////////////////////
		// Now, no longer a toggle! Duh. Thanks to iRobot
		// and various videogames that Alex has played for
		// additional inspiration. And Alex's paranoia about
		// accuracy has caused us to move it to the far buttons.
		///////////////////////////////////////////////////
		if (joy1Btn(7))
			DrivingScale = 0.2;

		else if (joy1Btn(5))
			DrivingScale = 0.1;

		else DrivingScale = 1;

		///////////////////////////////////////////////////
		//               Apply joystick control
		///////////////////////////////////////////////////
		if (abs(joystick.joy1_x2) > JOY_NOISE) // Check for noise
		{
			rotate = joystick.joy1_x2 * JOY_SCALE;
			ReverseCount = 0;
		}

		else rotate = 0;

		if (sqrt(SQR(joystick.joy1_x1) + SQR(joystick.joy1_y1)) > JOY_NOISE) // Check for noise
		{
			/* Set driving values */
			MoveX = joystick.joy1_x1;
			MoveY = joystick.joy1_y1;
		}
		else // Values are too small
		{
			MoveX = 0;
			MoveY = 0;
		}

		///////////////////////////////////////////////////
		//            Apply Driving Mode
		///////////////////////////////////////////////////
		if (MagicMode) // Drive in car mode
		{
			// MoveX and MoveY are the joystick values

			if (abs(joystick.joy1_y2) > JOY_NOISE)
			{
				MoveX = joystick.joy1_y2;
			}
			else MoveX = 0;

			motor[omniFL] =  Round(DrivingScale * JOY_SCALE * MoveY);
			motor[omniBL] =  Round(DrivingScale * JOY_SCALE * MoveY);
			motor[omniFR] = -Round(DrivingScale * JOY_SCALE * MoveX);
			motor[omniBR] = -Round(DrivingScale * JOY_SCALE * MoveX);
		}
		else // Drive in omnimode
		{
			/*
			if (Filtered && MoveX > 0)
			{
				// Possible use reference method
				ufRotateAngle = atan((MoveY/127)/(MoveX/127));
				ufSpeed = sqrt(SQR(MoveX) + SQR(MoveY));

				SetMoveMath(ufRotateAngle + UserAngle, ufSpeed, rotate);
			}*/

			motor[omniFL] = Round(DrivingScale * (JOY_SCALE * (+MoveX + MoveY) + rotate));
			motor[omniFR] = Round(DrivingScale * (JOY_SCALE * (+MoveX - MoveY) + rotate));
			motor[omniBL] = Round(DrivingScale * (JOY_SCALE * (-MoveX + MoveY) + rotate));
			motor[omniBR] = Round(DrivingScale * (JOY_SCALE * (-MoveX - MoveY) + rotate));
		}

		///////////////////////////////////////////////////
		//             Button: OmniSwitch
		///////////////////////////////////////////////////
		//   Switch the robot from omnimode to tankmode
		///////////////////////////////////////////////////
		if (joy1Btn(3))
		{
			if (cModeSwitch < 65)
				cModeSwitch++;

			else // Button Press!
			{
				// This just sounds cool.
				if (bSoundQueueAvailable)
					PlayImmediateTone(80, 60);

				MagicMode = !MagicMode;
				StartTask(SetWheels(MagicMode, true));
				cModeSwitch = -120;
			}
		}
		else cModeSwitch = 0;


		///////////////////////////////////////////////////
		//            Button: Userfilter reset
		///////////////////////////////////////////////////
		// Used to realign the user filter, just in case
		///////////////////////////////////////////////////
		if (joy1Btn(1))
		{
			if (cFilterReset > BUTTON_TIMER)
				cFilterReset++;

			else // Button Press
			{
				PlayImmediateTone(120, 20);
				UserAngle = SensorValue[comp];

				cFilterReset = -60;
			}
		}
		else cFilterReset = 0;

		///////////////////////////////////////////////////
		//             Button: Filter Toggle
		///////////////////////////////////////////////////
		//  Used to toggle the userfilter. If it doesn't
		//  work, the old driving code works as backup.
		///////////////////////////////////////////////////
		if (joy1Btn(8))
		{
			if (cFilterToggle > 115)
				cFilterToggle++;

			else
			{
				if (Filtered)
					PlayImmediateTone(40, 20);

				else PlayImmediateTone(140, 20);

				Filtered = !Filtered;

				cFilterToggle = -100;
			}
		}

		///////////////////////////////////////////////////
		//          Button Rotate to user filter
		///////////////////////////////////////////////////
		//    Turns the robot to align with the user.
		///////////////////////////////////////////////////
		if (joy1Btn(6))
		{
			if (cTurnToRings < BUTTON_TIMER)
				cTurnToRings++;
			else
			{
				//StartTask(tTurnDegrees(Variance(SensorValue[comp], UserAngle)));
				cTurnToRings = -100;
			}
		}
		///////////////////////////////////////////////////
		//         Button Rotate to face rings
		///////////////////////////////////////////////////
		//  Turns the robot to face the ring dispenser.
		///////////////////////////////////////////////////
		if (joy2Btn(4))
		{
			if (cTurnToUser < BUTTON_TIMER)
				cTurnToUser++;
			else
			{
				//StartTask(tTurnDegrees(Variance(SensorValue[comp], RingAngle)));
				cTurnToUser = -100;
			}
		}


//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                   Grabber and possibly arm
//////////////////////////////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////
		//            Button: Grabber Vibrate
		///////////////////////////////////////////////////
		// Vibrates the grabber as a way of teasing rings
		//               on and off of it.
		///////////////////////////////////////////////////
		if (joy2Btn(2))
		{
			if (cArmVibrate < BUTTON_TIMER)
				cArmVibrate++;

			else // button press
			{
				if (ShakeForward)
				{
					servo[armClaw] += A_SHAKE_AMPLITUDE_T;
				}
		       else servo[armClaw] -= A_SHAKE_AMPLITUDE_T;

				ShakeForward = !ShakeForward;

				cArmVibrate = 30;
			}
		}
		else cArmVibrate = 0;

		///////////////////////////////////////////////////
		//            Joystick Grabber Reset
		///////////////////////////////////////////////////
		//           Used to reset the grabber.
		///////////////////////////////////////////////////
		if (joy2Btn(3))
		{
			if (cArmCenter < BUTTON_TIMER)
				cArmCenter++;

			else // Button press
			{
				servo[armClaw] = A_C_REGTILT;

				cArmCenter = 0;
			}
		}
		else cArmCenter = 0;

		///////////////////////////////////////////////////
		//        Joystick Grabber Functions
		///////////////////////////////////////////////////
		if (abs(joystick.joy2_y2) > 30)
		{
			if (cArmJoystick < 20)
				cArmJoystick++;

			else // joystick press
			{
				int value = abs(joystick.joy2_y2)/joystick.joy2_y2;
				servo[armClaw] += 6*value;

				cArmJoystick = 0;
			}
		}
		else cArmJoystick = 0;


//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                          Lift
//////////////////////////////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////
		//               Lift joystick
		///////////////////////////////////////////////////
		//    Borrowed from our epic driving code
		///////////////////////////////////////////////////
		/* Setting the scale here */
		if (joy2Btn(7)) // TODO: Replace with correct button.
			LiftScale = 0.5;

		else if (joy1Btn(5)) // Replace with correct button..
			LiftScale = 0.2;

		else LiftScale = 1;

		// Set the motors like in driving code
		if (abs(joystick.joy2_y1) > JOY_NOISE)
		{
			motor[lift] = Round(joystick.joy2_y1 * JOY_SCALE * LiftScale);
		}
		else // Not being lifted
		{
			motor[lift] = 0;
		}

	} // while
} // task main
