#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S2_C1_1,     FLBR,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     FRBL,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     blank,         tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is to test the pull up mechanism.

//Unfortunately, while I grabbed all of the needed electronics for only driving the robot,
//I forgot to take a motor and servo controller home and there was a large snow storm that caused the cancellation of Sunday Robotics.


//Diagnal wheels need to be connected via alligator clips. Due to being unable to reverse individual motors programatically,
//the positive terminal of one wheel needs to be connected to the negative terminal of another wheel.

#include "JoystickDriver.c"

#define JOY_SCALE 0.77
// How far off the joystick can be
#define JOY_NOISE 12

float quarterPI = PI / 4;
float theta, speed; // Vector math to the wheel



void driveMeccanum(float speed, float theta)
{
	motor[FLBR] = round(speed * sin(theta + quarterPI));
	motor[FRBL] = round(speed * -cos(theta + quarterPI));
}
int sqr (int input)
{ return input * input; }

task main()
{
	while(1==1)
	{
		getJoystickSettings(joystick);

		speed = sqrt(sqr(joystick.joy1_x1) + sqr(joystick.joy1_y1));

		if (speed > JOY_NOISE)
		{
			theta = atan2(-joystick.joy1_y1, -joystick.joy1_x1);
		}
		else
		{
			speed = 0;
			theta = 0;
		}

		driveMeccanum(speed, theta);
if (abs(joystick.joy1_y2) > JOY_NOISE)
{
	motor[Lift] = joystick.joy1_y2 * JOY_SCALE;
}
else
	motor[Lift] = 0;

	}
}
