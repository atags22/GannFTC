#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     BR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     FR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BlockatorTL,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     PullBottom,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     BL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     FL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C1_1,     BlockatorTR,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    PullTop,              tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_2,    BlockDrop,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    BlockatorBL,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    BlockatorBR,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_5,    FlagRotater,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////
// Hutzbots Teleop Code	//
//         A            //
//        / \           //
//       /   \          //
// <----+-----+---->    //
//  \  /       \  /     //
//   \/         \/      //
//   /\         /\      //
//  /  \       /  \     //
// <----+-----+---->    //
//       \   /          //
//        \ /           //
//         V            //
//////////////////////////

//////////////////////////////////////
// Our opportunites are televised. //
////////////////////////////////////
// Alex Tagieri (math/arm),
// Joshua Hailman (form, appearancen),
// Hodaya Propp (Mathymath/flag)
////////////////////////////////



////////////////////////
// Debugging windows //
//////////////////////
//#pragma DebuggerWindows("joystickSimple")


//////////////////////////
// Octothorpe Includes //
////////////////////////
#include "Youtilities.c"
#include "JoystickDriver.c"


//////////////////////////////////////////////////
//							Button Counters
//////////////////////////////////////////////////
// These variables make sure our button events
// aren't toggled multiple times during execution.
//////////////////////////////////////////////////
bool bToggleFilter = 0;
bool bResetFilter  = 0;
byte cAngleSet = 0;


//////////////////////////////////////////////////
//						#define'd Constants
//////////////////////////////////////////////////
// Using #define can make code easier to read
// and to edit.
//////////////////////////////////////////////////
// Scale the joystick to 100
#define JOY_SCALE 0.77
// How far off the joystick can be
#define JOY_NOISE 10
//Light sensor value reported when sensor sees line
#define LIGHT_THRESHOLD 17
//Button Press Timer
#define BUTTON_MAX 50

//////////////////////////////////////////////////
//             Driving Variables
//////////////////////////////////////////////////
bool UserFilter = false; // Do we filter the user
float DrivingScale = 1; // The scale of the robot for driving
int Rotate; // How much to rotate the robot.
float theta, speed; // Vector math to the wheel
float rotateMultiplier = 100.0 / 127.0;

//////////////////////////////////////////////////
//			 Text summary of the controls!
//////////////////////////////////////////////////

///////////////////////
//			Joystick 1
///////////////////////
//
// Left	 joystick: drive robot omniwheel mode
// Right joystick: rotate robot / reset target compass value
// Button One: Lift arm?
// Button Two: Follow a line // Should we have this available teleop?
// Buttons LB, RB, and Y: Play La Cuca Racha
//
//
//
///////////////////////
//     Joystick 2
///////////////////////
//
//Joystick Y1: Shoulder raiser/lowerer
//
//Button Four: Latch on pullup bar moves one way
//Button Two: Latch on pullup bar moves the other way.
//Button LB: Pullup mech moves one way.
//Button RB: Pullup mech moves the other way.
//Button 3: Get blocks (continuous rotation on)
//Button 5: Get blocks (continuous rotation off)
//

////////////////////////////////////////////////////////////////////////////////////////////////////
//																			 task main()
////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	//waitForStart();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	// 																	Various button functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////
	// Button(s) to disable // what does this mean

	//////////////////////////////////////////////////
	// Initialization of things and stuff and objects
	//////////////////////////////////////////////////
//	userAngle = SensorValue(Comp);
	nVolume = 3;   // Set the robot volume
//	robotAngle = SensorValue(Comp);
	//////////////////////////////////////////////////
	//						while (true) loop
	//////////////////////////////////////////////////
	while (true)
	{
		//////////////////////////////////////////////////
		//					Reset joystick values
		//////////////////////////////////////////////////
		getJoystickSettings(joystick);

		//////////////////////////////////////////////////
		//         Driving Speed Modification
		//////////////////////////////////////////////////
		// Allows user to slow down robot using buttons.
		//////////////////////////////////////////////////
		if (joy1Btn(5) && joy1Btn(7))
			DrivingScale = 1.3;

		else if (joy1Btn(5))
			DrivingScale = .5;

		else if (joy1Btn(7))
			DrivingScale = .25;

		else // Neither button pressed
			DrivingScale = 1;

		//////////////////////////////////////////////////
		//        Button 12: Reset User Angle
		//////////////////////////////////////////////////
		//  Reset user angle if right joystick pressed
		//////////////////////////////////////////////////
		if (joy1Btn(10))
		{
			if (cAngleSet < BUTTON_MAX)
			{
				cAngleSet++;
			}
			else
			{
				PlayTone(880,14);
	//			userAngle = SensorValue[Comp];
				cAngleSet = 0;
			}
		}
		else cAngleSet = 0;

		////////////////////////////////////////////////////////////////////////////////////////////////////
		// 																			Drive the robot
		////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////
		//             Regular driving
		//////////////////////////////////////////////////

		// Determine if controls
		// are above noise level
		/////////////////////////
		speed = sqrt(sqr(joystick.joy1_x1) + sqr(joystick.joy1_y1));

		if (speed > JOY_NOISE)
		{
			/////////////////////////
			//get robot angle
			/////////////////////////


		//getRobotAngle();



			/////////////////////////
			//   Get mathymaths
			/////////////////////////
			theta = atan2(-joystick.joy1_y1, joystick.joy1_x1);

			/////////////////////////
			//   Do the user angle
			/////////////////////////
			//if ((UserFilter || joy1Btn(12)) && !joy1Btn(11))
				// It could be:
				// > theta - (user + compass)
				//theta = 5;
				//theta = theta + (userAngle - robotAngle);
		}
		else // The joystick values are small enough to fail
		{
			/////////////////////////
			//  No driving at all
			/////////////////////////
			theta = 0; speed = 0;
		}

		//////////////////////////////////////////////////
		// 									RotatComp
		//////////////////////////////////////////////////
		if (abs(joystick.joy1_x2) > JOY_NOISE)
		{
			Rotate = joystick.joy1_x2;
		}
		else // No rotation is detected
		{
			Rotate = 0;
		}

		//////////////////////////////////////////////////
		// 				  	Driving Application
		//////////////////////////////////////////////////
		//motor[FL] = motor[BR] = round(speed * sin(theta - quarterPI) * DrivingScale) + Rotate * rotateMultiplier; // + Rotate;
		//motor[FR] = motor[BL] = round(speed * cos(theta - quarterPI) * DrivingScale) + Rotate * rotateMultiplier;
		driveMeccanum(speed, theta, DrivingScale, Rotate);

		////////////////////////////////////////////////////////////////////////////////////////////////////
		// 																		Opeation the hardeae wsguf
		////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////
		//										Pullups!
		//////////////////////////////////////////////////

		///////////////////////
		//Move latch
		///////////////////////

		//for cont. rotate servos, 0 is full speed back, 127 is stopped, and 255 is full speed forward.

		if (joy2Btn(2))
		{
			servo[PullTop] = 255; // Full speed ahead!
		}
		else if (joy2Btn(4))
		{
			servo[PullTop] = 0; // Woah there. Back it up!
		}
		else
		{
			servo[PullTop] = 127;
		}

		///////////////////////
		//       Raise robot
		///////////////////////

		if (joy2Btn(6))
		{
			motor[BlockatorTL] = motor[BlockatorTR] = 100;
		}
		else if (joy2Btn(8))
		{
			motor[BlockatorTL] = motor[BlockatorTR] = -100;
		}
		else
		{
			motor[BlockatorTL] = motor[BlockatorTR] = 0;

		}

		///////////////////////
		//
		//		Flag raiser
		//
		///////////////////////

		if (joy2Btn(5))
		{
			motor[Flag] = 100;
		}
		else if (joy2Btn(7))
		{
			motor[Flag] = -100;
		}
		else motor[Flag] = 0;



		//////////////////////////////////////////////
		//
		//								Autonomous arm mover
		//
		//////////////////////////////////////////////

if (joy2Btn(1))
{
	servo[BlockDrop] += 1;
}
if (joy2Btn(3))
{
	servo[BlockDrop] += -1;
}



//Flag servo night before milton qualifier 2014
if (ServoValue[FlagRotater] > 5 || ServoValue[FlagRotater] < 250)
{
	if (abs(joystick.joy2_x2) > JOY_NOISE)
	{
		servo[FlagRotater] += .1 * joystick.joy2_x2;
	}
}
}
}

		//////////////////////////////////////////////
		//								Getting blocks
		//////////////////////////////////////////////

		///////////////////////
		//   Shoulder raiser
		///////////////////////
/*		if (joy1Btn(9))
		{
			PowerVariable = 3;
		}
		else
		{
			PowerVariable = 1;
		}
		if ((joystick.joy1_y2) > JOY_NOISE)
		{
			motor[Shoulder] = (9.63661 * pow(1.01845,joystick.joy1_y2));
			//Move arm that gets blocks
			//Let's do something really mathy here. I'm thinking an exponential function to increase accuracy. Concurrers? Great. Let's write it.
			//Update: I wrote it!
			//I got the values for this function by solving ab^12=12 and ab^128=100 for a and b. When the joystick is 12, the motors turn at 12. When the joystick is 100, the motors turn at 100.
		}
		else if (joystick.joy1_y2 < -JOY_NOISE)
			motor[Shoulder] = (-9.63661 * pow(1.01845,-joystick.joy1_y2));
		else
		{
			motor[Shoulder] = 0;
		}
*/
		///////////////////////
		//   Block getter
		///////////////////////
/*		int SweepCounter = 0;
		int ReverseCounter = 0;

		if (joy1Btn(1))
		{
			if (SweepCounter < BUTTON_MAX)
			{
				SweepCounter ++;
			}
			else
			{
				SweepCounter = 0;
				cSweepDustpan = !cSweepDustpan;
			}
		}

		if (cSweepDustpan == true)
		{
			if (motor[GrabL] == 0)
			{
				motor[GrabL] = motor[GrabR] = 80;
				cSweepDustpan = false;
			}
			else
			{
				motor[GrabL] = motor[GrabR] = 0;
				cSweepDustpan = false;
			}
		}

		//Going Backwards

		if (joy1Btn(3))
		{
			if (ReverseCounter < BUTTON_MAX)
			{
				ReverseCounter ++;
			}
			else //ReverseCounter is at the limit
			{
				ReverseCounter = 0;
				SweepBack = true;
			}
			if (SweepBack)
			{
				if (motor[GrabL] == 0)
				{
					motor[GrabL] = motor[GrabR] = -80;
					SweepBack = false;
				}
				else
				{
					motor[GrabL] = motor[GrabR] = 0;
				}
			}
		}
*/
			///////////////////////
			//    Leveler servo
			///////////////////////
/*
			if (joy1Btn(9))
			{
					servo[BTMS] = 240;
			}
			else if (joy1Btn(10))
			{
				servo[BTMS] = 10;
			}
			else servo[BTMS] = 127;
		}
	}
*/


















































	// Apply compass to theta
	//int Comp_Angle = addAngles(SensorValue[compass], -270); // * PI/180; //The math function wants the 0 angle to be the angle to the right of the robot, but the compass reports the 0 angle as directly in front of the robot. Use comp_angle instead of sensorvalue(compass).
	//float useroffset = ((Comp_Angle - userAngle) * PI/2) / 360;
	//			if (abs(useroffset) < 20) useroffset = 0;
	//theta = angleOffset(theta, useroffset);
	//theta += (theta + (angleOffset(userAngle, Comp_Angle))) % (2 * PI);
	//theta = theta + useroffset;
	//			theta = addAngles(theta, useroffset);															 //THE FILTER LINE!!!!!
	//if (joystick.joy1_y1 > 0) theta += pi;
	// set the proxies to degree, power via vectors
	// right side is reversed // degToRad = pi / 4;
