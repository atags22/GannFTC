#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     BR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     FR,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BlockatorTL,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     PullBottom,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     BL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     FL,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C1_1,     BlockatorTR,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    PullTop,              tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_2,    BlockDrop,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    BlockatorBL,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    BlockatorBR,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_5,    none5,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    none6,                tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													 Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"	 //Include file to "handle" the Bluetooth messages.


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																		initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//	 1. Move motors and servos to a preset position.
//	 2. Some sensor types take a short while to reach stable values during which time it is best that
//			robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//			"bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// kButtonCenter or kEnterButton?
// Someone lovingly wrote out these values.
#define LEFT 2
#define RIGHT 1
#define CENTER 3
#define BACK 0

bool isLeftTurn = false;
bool isCornerMode = false;
byte extraTime = 0;
byte rampType = 0;

void AutoNoMouseGUI()
{
	sbyte choosing = 0; string choiceText; bool shouldExtraBreak = false;
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	nNxtExitClicks = -1;
	bDisplayDiagnostics = false;
	eraseDisplay();
	nVolume = 2;

	nxtDisplayBigTextLine(0, "6308");
	nxtDisplayBigStringAt(1, 44, "Hutzbots");
	nxtDisplayCenteredTextLine(5, "Auto No Mouse");
	nxtDisplayCenteredTextLine(6, "Multi-Vector");
	nxtDisplayCenteredTextLine(7, "Assault Mode");
	PlayImmediateTone(587, 45);
	PlayImmediateTone(880, 35);
	wait1Msec(1800);
	eraseDisplay();


	/////////////////////////////////
	// Option One: Starting Delay! //
	/////////////////////////////////

	while (true)
	{
		shouldExtraBreak = false;
		// Step one: show the user options
		nxtDisplayCenteredTextLine(0, "<D> P  S  R ");
		nxtDisplayCenteredTextLine(2, "Starting delay");
		nxtDisplayCenteredTextLine(4, " off >"); choosing = 0;
		nxtDisplayCenteredTextLine(6, "It is the delay");

		// Step two: listen to the buttons and/or heart
		while (nNxtButtonPressed != CENTER) //this will be executed until =EnterButton holds true
		{
			// if you're pressing the right button, and choosing a delay that's less than 10
			if (nNxtButtonPressed == RIGHT && choosing < 14)
			{
				choosing++;
				if (choosing == 14) choiceText = "<	%i	 ";
				else choiceText = "<  %i  >";

				// string formatting theory:
				// "The fuel level is x, the altitude is y, time is t", also use x = fuel, y = altitude, t = time
				// string text = "The fuel level is " + fuelLevel + ", the altitude is " + getAltitude() + ", time is " + time

				// "< %i >", 10 -> "< 10 >"
				nxtDisplayCenteredTextLine(4, choiceText, choosing);
				wait1Msec(220);
			}
			else if (nNxtButtonPressed == LEFT && choosing > 0)
			{
				choosing--;
				if (choosing == 0) choiceText = "	off >";
				else choiceText = "<  %i  >";
				nxtDisplayCenteredTextLine(4, choiceText, choosing);
				wait1Msec(400);
			}
			else if (nNxtButtonPressed == BACK)
			{
				StopAllTasks(); // Exit the program
			}
		}
		extraTime = choosing;
		if (shouldExtraBreak) { wait1Msec(220); break; }
		// Wait until you release the enter button, so that
		// we don't skip to the next stage.
		while (nNxtButtonPressed == CENTER) {}

		// senioritis = SeniorCodeItIs

		////////////////////////////////
		// Option Two: Starting Place //
		////////////////////////////////

		while (true)
		{
			shouldExtraBreak = false;
			nxtDisplayCenteredTextLine(0, " D <P> T  R ");
			nxtDisplayCenteredTextLine(2, "Starting place");
			nxtDisplayCenteredTextLine(4, "<Side> Corner "); choosing = 0;
			nxtDisplayCenteredTextLine(6, "Where it starts");

			while (nNxtButtonPressed != CENTER)
			{
				if (nNxtButtonPressed == LEFT)
				{
					nxtDisplayCenteredTextLine(4, "<Side> Corner ");
					nxtDisplayCenteredTextLine(6, "On the side.");
					choosing = 0;
				}
				else if (nNxtButtonPressed == RIGHT)
				{
					nxtDisplayCenteredTextLine(4, " Side <Corner>");
					choosing = 1;
					nxtDisplayCenteredTextLine(6, "In the corner.");
				}
				else if (nNxtButtonPressed == 0)
				{
					shouldExtraBreak = true; break;
				}
			}
			if (shouldExtraBreak) { wait1Msec(220); break; }
			if (choosing == 1) isCornerMode = true;
			while (nNxtButtonPressed == CENTER) {}


			//////////////////////////////////////
			// Option Three: Turning Direction! //
			//////////////////////////////////////

			while (true)
			{
				shouldExtraBreak = false;
				nxtDisplayCenteredTextLine(0, " D  P <T> R ");
				nxtDisplayCenteredTextLine(2, "Turn diretion"); choosing = 0;
				if (isCornerMode)
				{
					nxtDisplayCenteredTextLine(4, "<Left> Right ");
					nxtDisplayCenteredTextLine(6, "Will drive to the left first.");
				}
				else
				{
					nxtDisplayCenteredTextLine(4, "Side mode can't");
					nxtDisplayCenteredTextLine(6, "start on right.");
				}

				while (nNxtButtonPressed != CENTER)
				{
					if (isCornerMode)
					{
						if (nNxtButtonPressed == LEFT)
						{
							nxtDisplayCenteredTextLine(4, "<Left> Right ");
							nxtDisplayCenteredTextLine(6, "Turn left");
							choosing = 0; wait1Msec(20);
						}
						else if (nNxtButtonPressed == RIGHT)
						{
							nxtDisplayCenteredTextLine(4, " Left <Right>");
							nxtDisplayCenteredTextLine(6, "Turn right");
							choosing = 1; wait1Msec(20);
						}
					}
					if (nNxtButtonPressed == BACK)
					{
						shouldExtraBreak = true; break;
					}
				}
				if (shouldExtraBreak == true) { wait1Msec(220); break; }
				if (choosing == 0) isLeftTurn = true;
				// This means we don't continue until they lift up from the
				// enter button. It makes it a little more smooth.
				while (nNxtButtonPressed == CENTER) {}



				////////////////////////////////
				// Option Four: Ramping mode! //
				////////////////////////////////

				while (true)
				{
					shouldExtraBreak = false;
					nxtDisplayCenteredTextLine(0, " F D P T<R>");
					nxtDisplayCenteredTextLine(2, "Ramping amount");
					nxtDisplayCenteredTextLine(4, " Part <Full> 2x "); choosing = 1;
					nxtDisplayCenteredTextLine(6, "How much ramping to do.");

					while (nNxtButtonPressed != CENTER)
					{
						if (nNxtButtonPressed == LEFT && choosing > 0)
						{
							choosing--;
							if (choosing == 0)
							{
								choiceText = "<Part> Full 2x ";
								nxtDisplayCenteredTextLine(6, "Only climbing up partway.");
								wait1Msec(300);
							}
							else if (choosing == 1)
							{
								choiceText = " Part <Full> 2x ";
								nxtDisplayCenteredTextLine(6, "Going up the ramp.");
								wait1Msec(300);
							}
							nxtDisplayCenteredTextLine(4, choiceText);
						}
						else if (nNxtButtonPressed == RIGHT)
						{
							choosing++;
							if (choosing == 1)
							{
								choiceText = " Part <Full> 2x ";
								nxtDisplayCenteredTextLine(6, "Going up the ramp.");
							}
							else
							{
								choiceText = " Part Full <2x>";
								nxtDisplayCenteredTextLine(6, "Going all the way across.");
							}
							nxtDisplayCenteredTextLine(4, choiceText);
							wait1Msec(300);
						}
						else if (nNxtButtonPressed == BACK)
						{
							shouldExtraBreak = true; break;
						}
					}
					if (shouldExtraBreak) { wait1Msec(160); break; }
					rampType = choosing; while (nNxtButtonPressed == CENTER) {}

					string rampMode = "normal";
					if (choosing == 0)			rampMode = "partly";
					else if (choosing == 2) rampMode = "extra";


					////////////////////////////////
					// Final check: Confirmation! //
					////////////////////////////////

					eraseDisplay();

					while (true)
					{
						shouldExtraBreak = false;
						nxtDisplayCenteredTextLine(0, "Nice job! Set:");

						if (extraTime != 0)
							nxtDisplayTextLine(2, "Delay %i", extraTime);
						else nxtDisplayTextLine(2, "Delay off");

						nxtDisplayTextLine(3, "From	 %s", (isCornerMode ? "corner" : "side"));

						if (isCornerMode)
							nxtDisplayTextLine(4, "Turn	 %s", (isLeftTurn ? "left" : "right"));
						else nxtDisplayTextLine(4, "No turn side mode");

						nxtDisplayTextLine(5, "Ramp	 %s", rampMode);

						while (nNxtButtonPressed != CENTER)
						{
							if (nNxtButtonPressed == BACK)
							{
								shouldExtraBreak = true;
								eraseDisplay();
								break;
							}
						}
						// press center
						if (shouldExtraBreak) break;
						while (nNxtButtonPressed == CENTER) { }
						PlayImmediateTone(880, 45);
						PlayImmediateTone(587, 35);
						wait1Msec(666);
						bDisplayDiagnostics = true;
						return;
					}

				} // end 4th while

			} // end third while

		} // end second while
	}
}

//for debugging
//task main()
//{
	//AutoNoMouseGUI();
//}

/*
GOTO SYNTAX IS BAD
label1:
firstchoice();

secondChoice();
if (back) goto label1;


LOOPS
while (true)
{
firstchoice();

while (true)
{
secondchoice();
if (shouldbreak) break;

// while true third...
}

}



*/
